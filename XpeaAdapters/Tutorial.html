<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
       "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>XPEA Tutorial</title>
  <meta name="generator" content="amaya 9.51, see http://www.w3.org/Amaya/" />
  <link rel="stylesheet" type="text/css" href="Tutorial.css" />
</head>

<body>
<h1 style="text-align: center">XML Path Event API</h1>

<div class="toc">
<ul>
  <li><a href="#WhatIs">What exactly is XPEA?</a></li>
  <li><a href="#HowDiff">How is this different from XPath/XSLT
  processing?</a></li>
  <li><a href="#WhenUse">When should one use XPEA?</a>
    <ul>
      <li><a href="#Advantages">Advantages</a></li>
      <li><a href="#Disadvantages">Disadvantages</a></li>
    </ul>
  </li>
  <li><a href="#SimpleEx">A simple example</a></li>
  <li><a href="#ComplexEx">A more complex example - transforming XML to
    HTML</a></li>
</ul>
</div>

<h2 id="WhatIs">What exactly is XPEA?</h2>

<p>The best way to understand it is to compare it with SAX. Both are APIs for
processing XML in an event based - also called 'streaming' - style. The
difference lies in when events are fired, and what handlers are called. In
SAX, all XML content triggers call-backs to the content handler. That is, for
every element start-tag encountered the same application code is called
(unless one assigns another content handler dynamically), and any
document-specific state must be maintained by the application. In XPEA,
different handlers can be associated with specific paths in the XML document.
For instance, if we are only interested in an element E which is a child of
element A, then we can register a "pattern matching path" consisting of nodes
"A" and "E" with a handler tied to node "E".</p>

<h2 id="HowDiff">How is this different from XPath/XSLT processing?</h2>

<p>In XSLT an XPath expression denotes a set of matching nodes, which is used
as input for some processing. For example, the expression "//A/B" matches all
nodes/elements "B" whose parent is element "A". This also means that random
access to the full XML document is assumed, therefore the underlying
representation often is a DOM, and the document needs to be present in
memory.</p>

<p>In XPEA a "path" of nodes represents a set of events, and these events are
triggered in a specific - forward-only order. For instance, we could have a
"path" of a "relative" node "A" followed by an "absolute node" B, and we can
shoose the same textual representation as above: "//A/B". Such nodes are
represented in XPEA by subclasses of the class
<code><strong>XmlMatchNode</strong></code>. However, we still need to attach
handlers to these nodes, and we can do this for every node, not just the last
one (as it would correspond to XSLT). If we represent these handlers through
their index into a list of handlers, such an XPEA "pattern matching path"
would be represented in text form as "//A{0}/B{1}", where handler 0 gets
called for events on node "A" and handler 1 gets called for events on node
"B". So the conceptual difference is: if we had a handler only on node "B" we
could associate the events in XPEA with the set of nodes matched by the XPath
expression "//A/B", but we actually also have a handler on node "A", which
means we have <em>two</em> sets of events, the latter set matching the XPath
expression "//A".</p>

<p>Predicates in XPEA are implemented as call-backs to an application
supplied delegate of type <code>Predicate&lt;XmlPathStep&gt;</code>. The text
representation of tagging a node to be associated with a given predicate is
similar to how it is done for handlers, using a different delimiter - the
sqare bracket. Example: "//A[0]/B{0}" associates predicate 0 with node "A"
and handler 0 with node "B".</p>

<p>In addition, the nodes in XPEA can be arranged into tree form as well ,
not only into a linear arrangement. That is why the source documentation uses
the term "pattern matching tree". There is no elegant way to represent such a
tree in text form, however, individual branches of the tree may be linear and
therefore representable as a "pattern matching path". We could use the term
<em><strong>XPattern</strong></em> to identify the concept.</p>

<h2 id="WhenUse">When should one use XPEA?</h2>

<p>This depends on the kind of XML processing one wants to do. Below is a
list of advantages and disadvantages that can help in the decision.</p>

<h3 id="Advantages">Advantages</h3>
<ul>
  <li>Low memory requirements, even for large input documents. Very large
    files can likely not be processed with XSLT at all, however with XPEA
    there should be no limit other than platform constraints. Note: Since
    XPEA keeps track of the current path when processing an XML document,
    memory consumption depends on the document depth. That is, an extremely
    "deep" document (millions of levels) could theoretically still cause XPEA
    to run out of memory - but this is unlikely in practice.</li>
  <li>There is no new programming language to learn, just a relatively small
    API in a language that one already knows, and one is not restricted by
    the limitations of a specialized language. That is, if the type of
    processing required goes beyond converting one kind of text to another,
    then it is preferable to use a general programming language.</li>
  <li>Speed, as there is no separate program written in a different language
    (like XSLT) to be interpreted or compiled. There is also no DOM to
  build.</li>
</ul>

<h3 id="Disadvantages">Disadvantages</h3>
<ul>
  <li>There is more code to write in a general programming language than a
    language specialized for XML processing.</li>
  <li>Thinking in terms of events is more difficult then thinking in terms of
    sets of document elements.</li>
  <li>Forward-only processing becomes difficult if processing 'early' element
    requires information from 'late' elements. In this case one is forced to
    store the 'early' information and delay processing it until all
    information is complete. However, even in such a case one can choose a
    data representation that consumes less memory than a generic DOM, and one
    can even choose to save some data to a temporary file.</li>
</ul>

<h2 id="SimpleEx">A simple example</h2>

<p>This example is based on the "Basic" demo application included in the
distribution, but somewhat simplified. It also demonstrates the basic way of
using XPEA. The main goal of the application is to count the number of "div2"
elements in the document, corresponding to this XPattern expression
"spec/*/div1/div2". We also want to ignore those "div2" elements whose "div1"
parent has the id attribute "sec-conformance". A sample XML file containing
such elements is available in the "Demo/Basic" folder.</p>

<p>Let's define the handlers first. We derive from the helper class
<code>XmlElementHandler&lt;...&gt;</code> so that we do not have to implement
all the methods of <code>IElementhandler&lt;...&gt;</code>, but only those we
need.</p>

<div class="code">
<pre>  // A few shortcut aliases - binding the type parameters for the context and status object used in call-backs
  using IBasicElementHandler
    = IElementHandler&lt;StdPathContext&lt;EventStatus&gt;, StdMatchNode&lt;EventStatus&gt;, EventStatus&gt;;
  using BasicXmlElementHandler =
    XmlElementHandler&lt;StdPathContext&lt;EventStatus&gt;, StdMatchNode&lt;EventStatus&gt;, EventStatus&gt;;

  // handler for accumulating and printing out counts of "div2" nodes
  internal class Div1Handler: BasicXmlElementHandler, IBasicElementHandler
  { 
    private int div2Count = 0;
    private RichTextBox rtfBox;
    private string id;

    public Div1Handler(RichTextBox rtfBox) {
      this.rtfBox = rtfBox;
    }

    public void Activate(
      StdMatchNode&lt;EventStatus&gt; matchedNode
      XmlPathStep step,
      EventStatus status)
    {
      div2Count = 0;
      id = step.Attributes[new QName("id")].Value;
    }

    public void Deactivate(EventStatus status) {
      rtfBox.AppendText("div section: ");
      if (id != null)
        rtfBox.AppendText(id);
      rtfBox.AppendText(", " + div2Count.ToString() + " subsections" + Environment.NewLine);
    }

    public void IncDiv2() {
      div2Count++;
    }
  } 

  // handler for actually counting "div2" nodes
  internal class Div2Handler: BasicXmlElementHandler, IBasicElementHandler
  {
    private Div1Handler div1Handler;
   
    public Div2Handler(Div1Handler div1Handler) {
      this.div1Handler = div1Handler;
    }

    public void Deactivate(EventStatus status) {
      div1Handler.IncDiv2();
    } 
  }</pre>
</div>

<p>Now that we have defined the handler classes, the next step is to
configure the event dispatcher. This includes configuring the node for the
"div1" element with a <code>Predicate</code> instance to check for the
"sec-conformance" attribute. After that we can process the document.</p>

<div class="code">
<pre>  rtfBox.Clear();
  FileStream fs = new FileStream(fileBox.Text, FileMode.Open, FileAccess.Read);
  try {
    // instantiate event dispatcher
    SaxDispatcher&lt;EventStatus&gt; disp = new SaxDispatcher&lt;EventStatus&gt;();

    // instantiate handlers and configure dispatcher
    Div1Handler div1 = new Div1Handler(rtfBox);
    Div2Handler div2 = new Div2Handler(div1);
    // configure predicates array
    Predicate&lt;XmlPathStep&gt;[] predicates = new Predicate&lt;XmlPathStep&gt;[] {
      delegate(XmlPathStep step) {
        return step.Attributes[new QName("id")].Value != "sec-conformance";
      }
    };
    // no prefix map passed, we are not using QNames
    StdPath&lt;EventStatus&gt; path =
      pathFactory.Create("/spec/*//div1[0]{0}/div2{1}", predicates, div1, div2);
    path.AddTo(dispatcher.MatchTrees);

    // attach to SAX parser (IXmlReader instance) and process file
    disp.AttachTo(reader);
    InputSource&lt;Stream&gt; input = new InputSource&lt;Stream&gt;(fs);
    reader.Parse(input);
  }
  finally {
    fs.Close();
  }</pre>
</div>

<p>As an alternative to using predicates, one can disable processing of child
nodes (of the current node in the pattern matching tree) by calling
<code>StdMatchNode&lt;...&gt;.DisableDescendants</code> directly in the
handler. This would be in effect only as long as the current node is
active.</p>

<p>We could have also built the "pattern matching tree" without using the the
<code>StdPathFactory&lt;...&gt;</code> helper class:</p>

<div class="code">
<pre>  SaxDispatcher&lt;EventStatus&gt; disp = new SaxDispatcher&lt;EventStatus&gt;();
    
  // instantiate handlers and configure dispatcher
  Div1Handler div1 = new Div1Handler(rtfBox);
  Div2Handler div2 = new Div2Handler(div1);

  StdMatchNode&lt;EventStatus&gt; parentNode = new StdNamedNode&lt;EventStatus&gt;("spec");
  disp.MatchTrees.Add(parentNode);  // register root node with dispatcher

  StdMatchNode&lt;EventStatus&gt; childNode = new StdWildCardNode&lt;EventStatus&gt;();  // wild card
  parentNode.Children.Add(childNode);

  parentNode = childNode;
  childNode = new StdNamedNode&lt;EventStatus&gt;("div1", false, div1);  // relative path
  childNode.Predicate = delegate(XmlPathStep step) {
    return step.Attributes[new QName("id")].Value != "sec-conformance";
  };
  parentNode.Children.Add(childNode);

  parentNode = childNode;
  childNode = new StdNamedNode&lt;EventStatus&gt;("div2", div2);
  parentNode.Children.Add(childNode);</pre>
</div>

<h2 id="ComplexEx">A more complex example - transforming XML to HTML</h2>

<p>This example is based on the "Transform" demo application included in the
distribution, without all the detail. The input document contains inventory
information for a number of geographical regions, the resulting HTML document
will display this information using a table for each region, and display in
each row the inventory for a specific product (alphabetically sorted).</p>

<p>The XML document used - products.xml - looks basically like this
fragment:</p>

<div class="code">
<pre>  &lt;region area="Northwest"&gt;
    &lt;product&gt;
      &lt;prodid&gt;V123049&lt;/prodid&gt;
      &lt;name&gt;Bendable Sunglasses&lt;/name&gt;
      &lt;price&gt;30&lt;/price&gt;
      &lt;quantity&gt;1030&lt;/quantity&gt;
    &lt;/product&gt;
    ... more products
  &lt;/region&gt;
  ... more regions</pre>
</div>
<br />


<p>This leads us to a division of handlers and their responsibilities:</p>

<p>
<table class="handler" border="1">
  <thead>
    <tr>
      <th>Handler Classes</th>
      <th>Responsibilities</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DocumentHandler</code></td>
      <td>Sets up HTML document. Assigned to <code>DocHandler</code>
      property.</td>
    </tr>
    <tr>
      <td><code>RegionHandler</code></td>
      <td>Accumulates product list, sorts it and writes out HTML table.
        Associated with "region" element.</td>
    </tr>
    <tr>
      <td><code>ProductHandler</code></td>
      <td>Gathers product details and adds complete product instance to list.
        Associated with "product" element.</td>
    </tr>
    <tr>
      <td><code>ProductIdHandler</code>, <code>ProductNameHandler</code>,
        <code>ProductPriceHandler</code>,
      <code>ProductQuantityHandler</code></td>
      <td>Reads one specific field of product and assigns it to product
        instance. Associated with "prodid", "name", "price" and "quantity"
        elements.</td>
    </tr>
  </tbody>
</table>
</p>

<p>The <code>DocumentHandler's</code> purpose does not need much discussion -
for details please refer to the source code. The implementation of the other
handlers however can give some useful insights into XPEA.</p>

<p>The <code><strong>RegionHandler</strong></code> sets up the HTML table and
header in its <code>Activate</code> event. The <code>Deactivate</code>
implementation then sorts the list of products and fills the table, finishing
off with all the appropriate end tags. The <code>AddProduct</code> method is
exposed so that the <code>ProductHandler</code> can add product instances to
the list. Note that it derives from <code>StdXmlElementHandler</code>, which
provides empty implementations for all <code>IStdElementHandler</code>
methods so that we only need to implement those methods that perform actual
work.</p>

<div class="code">
<pre>  internal class RegionHandler: StdXmlElementHandler, IStdElementHandler
  {
    private XmlWriter writer;
    private List&lt;Product&gt; products;
    private int prodCount;
    private int quantity;

    public RegionHandler(XmlWriter writer) {
      this.writer = writer;
      products = new List&lt;Product&gt;();
    }

    public void Activate(
      StdMatchNode&lt;EventStatus&gt; matchedNode
      XmlPathStep step,
      TransformStatus status) 
    {
      products.Clear();
      prodCount = 0;
      quantity = 0;
      writer.WriteStartElement("span");
      writer.WriteAttributeString("class", "subhead");
      writer.WriteString("Region");
      writer.WriteEndElement();
      writer.WriteStartElement("span");
      writer.WriteAttributeString("class", "text");
      int attIndx = step.Attributes.GetIndex(new QName("area"));
      if (attIndx &lt; 0)
        status.SetCodeMsg(EventStatusCode.Error, "Attribute not found: 'area'");
      else
        writer.WriteString(step.Attributes[attIndx].Value);
      writer.WriteEndElement();
      writer.WriteElementString("br", "");
      writer.WriteElementString("br", "");
      writer.WriteStartElement("table");
      writer.WriteAttributeString("border", "1");
      writer.WriteStartElement("tr");
      writer.WriteElementString("th", "ID");
      writer.WriteElementString("th", "Name");
      writer.WriteElementString("th", "Price");
      writer.WriteElementString("th", "Quantity");
      writer.WriteEndElement();
    }

    public void Deactivate(TransformStatus status) {
      string nl = Environment.NewLine;
      products.Sort(Product.Compare);
      foreach (Product prod in products) {
        writer.WriteStartElement("tr");
        writer.WriteElementString("td", prod.Id);
        writer.WriteElementString("td", prod.Name);
        writer.WriteElementString("td", prod.Price);
        writer.WriteElementString("td", prod.Quantity);
        writer.WriteEndElement();
      }
      writer.WriteEndElement();
      writer.WriteStartElement("p");
      writer.WriteString("Total Products in region: " + prodCount.ToString());
      writer.WriteElementString("br", "");
      writer.WriteString("Total Inventory in region: " + quantity.ToString());
      writer.WriteEndElement();
      writer.WriteElementString("br", "");
    }

    internal void AddProduct(ref Product prod, int qty) {
      products.Add(prod);
      quantity += qty;
      prodCount++;
    }
  }</pre>
</div>

<p>The <code><strong>ProductHandler</strong></code> exposes its
<code>product</code> member as an <code>internal</code> field, allowing the
product detail handlers to assign values to the <code>product's</code>
members. When the product element's end tag is encountered, the
<code>Deactivate</code> event handler adds the complete <code>product</code>
instance to the list in the <code>RegionHandler</code>.</p>

<div class="code">
<pre>  internal struct Product
  {
    public string Id;
    public string Name;
    public string Price;
    public string Quantity;

    // for sorting
    public static int Compare(Product p1, Product p2) {
      return string.Compare(p1.Name, p2.Name);
    }
  }
  
  internal class ProductHandler: StdXmlElementHandler, IStdElementHandler
  {
    private RegionHandler region;
    internal Product product;
    internal int quantity;

    public ProductHandler(RegionHandler region) {
      this.region = region;
    }

    public void Deactivate(TransformStatus status) {
      region.AddProduct(ref product, quantity);
    }
  }</pre>
</div>

<p>The product detail handlers all work basically the same, so we only show
the <code>ProductNameHandler</code>. It simply collects character data and
assigns them on deactivation to the product's appropriate field (Name in this
case). The only thing noteworthy is that it derives from
<code>StdTextElementHandler</code>, which is useful for elements containing
character data as it accumulates them into a character buffer. The difference
to <code>StdXmlElementHandler</code> is that one should override the
<code>OnActivate</code>, <code>OnDeactivate</code> and <code>OnReset</code>
events rather than explicitly implement the <code>IStdElementHandler</code>
interface.</p>

<div class="code">
<pre>  internal class ProductNameHandler: StdTextElementHandler
  {
    private ProductHandler prodHandler;

    public ProductNameHandler(ProductHandler prodHandler) {
      this.prodHandler = prodHandler;
    }

    protected override void OnDeactivate(TransformStatus status) {
      prodHandler.product.Name = CopyBuffer();
    }
  }</pre>
</div>

<p>Now that we have discussed the handlers, all that is left to do is to have
a look processing the input document XPEA style. This is similar to how it is
done in the "Basic" demo - in this case we show the code for using the Expat
parser adapter. Looking closeley we can also see that instead of a "pattern
matching path" we now have a "pattern matching tree", as the
<code>ProductHandler</code> node has four children for product id, name,
price and quantity.</p>

<div class="code">
<pre>    private void SetupHandlers(StdEventDispatcher&lt;TransformStatus&gt; disp, XmlWriter writer) {
      RegionHandler region = new RegionHandler(writer);
      ProductHandler product = new ProductHandler(region);
      ProductIdHandler prodId = new ProductIdHandler(product);
      ProductNameHandler prodName = new ProductNameHandler(product);
      ProductPriceHandler prodPrice = new ProductPriceHandler(product);
      ProductQuantityHandler prodQuantity = new ProductQuantityHandler(product);

      // no prefix map passed, we are not using QNames
      StdPathFactory&lt;TransformStatus&gt; pathFactory = 
        new StdPathFactory&lt;TransformStatus&gt;(null, intern);

      // create a path first, then add extra nodes to make it a tree
      StdPath&lt;TransformStatus&gt; path =
        pathFactory.Create("//region{0}/product{1}/prodid{2}", region, product, prodId);
      StdMatchNode&lt;TransformStatus&gt; prodNode = path.Leaf.Parent;
      // by default, a node will be absolute unless specified otherwise
      StdMatchNode&lt;TransformStatus&gt; tmpNode =
        new StdNamedNode&lt;TransformStatus&gt;("name", prodName);
      prodNode.Children.Add(tmpNode);
      tmpNode = new StdNamedNode&lt;TransformStatus&gt;("price", prodPrice);
      prodNode.Children.Add(tmpNode);
      tmpNode = new StdNamedNode&lt;TransformStatus&gt;("quantity", prodQuantity);
      prodNode.Children.Add(tmpNode);
      path.AddTo(disp.MatchTrees);  // same as disp.MatchTrees.Add(path.Root);
    }

...
    outputBrowser.Url = null;
    FileStream inStream = new FileStream(inputFile, FileMode.Open, FileAccess.Read);
    try {
      FileStream outStream = new FileStream(outputFile, FileMode.Create);
      XmlWriter writer = XmlWriter.Create(outStream, writerSettings);
      try {
        ExpatDispatcher&lt;TransformStatus&gt; disp = new ExpatDispatcher&lt;TransformStatus&gt;();
        disp.DocHandler = new DocumentHandler(writer);
        SetupHandlers(disp, writer);
        XpeaExpatParser&lt;TransformStatus&gt; parser = disp.CreateAttachedParser(null, true);
        try {
          ParseStatus ps = disp.Parse(inStream);
          if (ps == ParseStatus.FatalError) {
            string errorMsg = LibExpat.XMLErrorString(parser.EntityContext.Error);
            throw new ApplicationException(errorMsg);
          }
        }
        finally {
          parser.Dispose();
        }
        disp.MatchTrees.Clear();  // not really necessary here
      }
      finally {
        writer.Close();
        outStream.Close();
      }
    }
    finally {
      inStream.Close();
    }
    outputBrowser.Url = new Uri("file:///" + outputFile);
  }
...</pre>
</div>
</body>
</html>
